% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mcmc_sampler.R
\name{pfdlm}
\alias{pfdlm}
\title{MCMC Sampling Algorithm for the Parametric Functional Dynamic Linear Model}
\usage{
pfdlm(Y, tau, f, nsave = 1000, nburn = 1000, nskip = 10,
  mcmc_params = list("beta", "fk"), h_step = NULL, evol_error_par = "RW",
  use_obs_SV = FALSE, orthogonalize = TRUE, log_prior_lambda_p = NULL,
  computeDIC = TRUE)
}
\arguments{
\item{Y}{the \code{T x m} data observation matrix, where \code{T} is the number of time points and \code{m} is the number of observation points (\code{NA}s allowed)}

\item{tau}{vector of observation points (\code{m}-dimensional)}

\item{f}{a function to compute the parametric component, which must return a \code{m x K_p} matrix
for \code{K_p} the number of parametric curves; may include a (scalar) nonlinear parameter argument}

\item{nsave}{number of MCMC iterations to record}

\item{nburn}{number of MCMC iterations to discard (burin-in)}

\item{nskip}{number of MCMC iterations to skip between saving iterations,
i.e., save every (nskip + 1)th draw}

\item{mcmc_params}{named list of parameters for which we store the MCMC output;
must be one or more of
\itemize{
\item "beta" (factors)
\item "fk" (loading curves)
\item "sigma_et" (observation error SD; possibly dynamic)
\item "lambda_p" (parametric nonlinear parameter)
\item "Wt" (evolution error variance)
\item "Yhat" (fitted values)
}}

\item{h_step}{integer for h-step forecasting; if NULL, do not compute any forecasts}

\item{evol_error_par}{string denoting the model for the parametric factor evolution;
must be one of
\itemize{
\item "RW": random walk with full evolution covariance matrix
\item "AR": independent AR(1) models for the factors
\item "VAR": full VAR coefficient matrix with full evolution covariance matrix
}}

\item{use_obs_SV}{logical; when TRUE, include a stochastic volatility model
for the observation error variance}

\item{orthogonalize}{logical; when TRUE, orthogonalize the parametric loadings matrix}

\item{log_prior_lambda_p}{a function to evaluate the log-prior for the nonlinear
parametric component; if \code{NULL}, do not sample the nonlinear component}

\item{computeDIC}{logical; if TRUE, compute the deviance information criterion \code{DIC}
and the effective number of parameters \code{p_d}}
}
\value{
A named list of the \code{nsave} MCMC samples for the parameters named in \code{mcmc_params}
}
\description{
Runs the MCMC for the (univariate) parametric FDLM. The options for the dynamic (parametric) factors are:
\enumerate{
\item Random walk model with full evolution covariance matrix
\item Independent AR(1) models (i.e., diagional covariance matrix)
\item Full vector autoregression (VAR) coefficient matrix with full evolution covariance matrix
}
}
\details{
The parametric function \code{f} should input an \code{m}-dimensional
vector of observation points, \code{tau}, and may include a (known or unknown) nonlinear
parameter, \code{lambda_p}. The function should return a \code{m x K_n} matrix, where \code{K_n} is the
number of parametric functions. For example, \code{f = function(tau) cbind(1,tau)}
includes an intercept and a linear term (\code{K_n = 2}). If the parametric function
includes a nonlinear term, for example, \code{f = function(tau, lambda_p) cbind(1,exp(-tau/lambda_p))},
then supply a (log) prior function via \code{log_prior_lambda_p} will allow for sampling of this
parameter. However, if \code{log_prior_lambda_p} is \code{NULL}, then the nonlinear parameter
will be fixed at its initialized value.
}
\note{
If \code{Tm} is large, then storing all posterior samples for \code{Yhat}, which is \code{nsave x T x m},  may be inefficient
}
\examples{
# Read in the yield curve data (US or UK):
data("US_Yields") # data("UK_Yields")

# Restrict to dates since 2012:
Y = Y[which(dates > as.Date("2012-01-01")),];
dates = dates[which(dates > as.Date("2012-01-01"))] # subset the dates for easy reference

# Center and scale for numerical purposes:
Y = scale(Y)

f = function(tau, lambda_p) f_ns(tau, lambda_p)[,1:2]
mcmc_output = pfdlm(Y, tau, f,
                   nsave = 1000, nburn = 100, nskip = 2,
                   mcmc_params = list("beta", "fk", "Yhat"),
                   evol_error_par = 'VAR')
# Plot the factors:
plot_factors(mcmc_output$beta, dates)

# Plot the factor loading curves:
plot_flc(mcmc_output$fk, tau)

# Some diagnostics: effective sample size(s) (may be slow!)
getEffSize(mcmc_output$beta)
getEffSize(mcmc_output$fk)
# getEffSize(mcmc_output$Yhat)

# Check the residuals:
Yhat = colMeans(mcmc_output$Yhat)
resids = Y - Yhat
dev.new(); persp(tau, dates, t(resids))
}
