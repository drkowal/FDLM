% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mcmc_sampler.R
\name{fdlm}
\alias{fdlm}
\title{MCMC Sampling Algorithm for the FDLM}
\usage{
fdlm(Y, tau, K = NULL, nsave = 1000, nburn = 1000, nskip = 10,
  mcmc_params = list("beta", "fk"), h_step = NULL, useFastImpute = TRUE,
  use_obs_SV = FALSE, includeBasisInnovation = TRUE, computeDIC = TRUE)
}
\arguments{
\item{Y}{the \code{T x m} data observation matrix, where \code{T} is the number of time points and \code{m} is the number of observation points (\code{NA}s allowed)}

\item{tau}{vector of observation points (\code{m}-dimensional)}

\item{K}{the number of factors; if NULL, use SVD-based proportion of variability explained}

\item{nsave}{number of MCMC iterations to record}

\item{nburn}{number of MCMC iterations to discard (burin-in)}

\item{nskip}{number of MCMC iterations to skip between saving iterations,
i.e., save every (nskip + 1)th draw}

\item{mcmc_params}{named list of parameters for which we store the MCMC output;
must be one or more of
\itemize{
\item "beta" (factors)
\item "fk" (loading curves)
\item "sigma_et" (observation error SD; possibly dynamic)
\item "Wt" (evolution error variance)
\item "Yhat" (fitted values)
}}

\item{h_step}{integer for h-step forecasting; if NULL, do not compute any forecasts}

\item{useFastImpute}{logical; when TRUE, use imputation/projection scheme for the dynamic factors; otherwise use full state space model for factors (slower)}

\item{use_obs_SV}{logical; when TRUE, include a stochastic volatility model
for the observation error variance}

\item{includeBasisInnovation}{logical; when TRUE, include an iid basis coefficient term for residual correlation
(i.e., the idiosyncratic error term for a factor model on the full basis matrix)}

\item{computeDIC}{logical; if TRUE, compute the deviance information criterion \code{DIC}
and the effective number of parameters \code{p_d}}
}
\value{
A named list of the \code{nsave} MCMC samples for the parameters named in \code{mcmc_params}
}
\description{
Runs the MCMC for the (univariate) FDLM under some default conditions:
\enumerate{
\item A random walk model for the dynamic factors;
\item A full \code{K x K} non-dynamic evolution error variance matrix;
\item A non-dynamic scalar multiple of the identity for the observation error variance.
}
}
\note{
If \code{Tm} is large, then storing all posterior samples for \code{Yhat}, which is \code{nsave x T x m},  may be inefficient
}
\examples{
# Read in the yield curve data (US or UK):
data("US_Yields") # data("UK_Yields")

# Restrict to dates since 2012:
Y = Y[which(dates > as.Date("2012-01-01")),];
dates = dates[which(dates > as.Date("2012-01-01"))] # subset the dates for easy reference

# Center and scale for numerical purposes:
Y = scale(Y)

# Run the MCMC:
mcmc_output = fdlm(Y, tau, K = 3,
                  nsave = 1000, nburn = 100, nskip = 2,
                  mcmc_params = list("beta", "fk", "Yhat", "sigma_et"))

# Plot the factors:
plot_factors(mcmc_output$beta, dates)

# Plot the factor loading curves:
plot_flc(mcmc_output$fk, tau)

# Some diagnostics: effective sample size(s) (may be slow!)
getEffSize(mcmc_output$beta)
getEffSize(mcmc_output$fk)
# getEffSize(mcmc_output$Yhat)

# Check the residuals:
Yhat = colMeans(mcmc_output$Yhat)
resids = Y - Yhat
dev.new(); persp(tau, dates, t(resids))

}
